\xchapter{Sistemas de Recomendação}{}
\label{cap:recommendation_system}
\acresetall 

Como já introduzido, Sistemas de Recomendação são utilizados como uma parte de um sistema maior. Neste capítulo abordamos uma revisão bibliográfica sobre Sistemas de Recomendação. Inicialmente é apresentada uma introdução, assim como as tarefas e os conceitos amplamente aplicados. Em seguida abordamos as formas de modelar os dados dos usuários como \textit{feedbacks} e a representação formal dos conjuntos de dados. As técnicas de recomendação de Filtragem Baseada em Conteúdo, Filtragem Colaborativa e Filtragem Híbrida são apresentadas, descritas e exemplificadas, assim como seus processos, vantagens e desvantagens. Ademais alguns algoritmos recomendadores utilizados neste trabalhado também são apresentados e formalmente descritos. Apresentamos, ainda, os protocolos de avaliação e as métricas de predição e ranque, as quais são largamente utilizadas para entender os resultados dos sistemas. Por fim, apresentamos algumas aplicações comerciais de sucesso.

\section{Introdução}
\citeonline{Ricci:2011} afirmam que, ``em sua forma mais simples, recomendações personalizadas são fornecidas como uma lista ordenada de itens candidatos". Para encontrar os itens que constituirão essa lista, Sistemas de Recomendação tentam predizer qual produto ou serviço mais agradará aos usuários, baseando-se no histórico das preferências.

\citeonline{Resnick:1997} em seu artigo nomeado ``Sistemas de Recomendação'' mostram que estes sistemas apoiam e aumentam o processo de recomendação. Basicamente, o que temos aqui são técnicas e ferramentas de programas para fornecer sugestões de itens que sejam úteis para um usuário. Nesses sistemas, ``item'' é um termo genérico utilizado para denotar o que o sistema oferece a um usuário \cite{Ricci:2011}.

Critérios como ``personalizada'', ``interessante'' e ``útil'' são essenciais na diferenciação dos Sistemas de Recomendação com os Sistemas de Recuperação de Informação, Filtragem de Informação ou Motores de Busca. Em um motor de busca, o sistema deve retornar tudo o que for correspondente aos termos utilizados na pesquisa. Porém, motores de buscas começaram a utilizar técnicas de introdução dos dados do usuário no processo de busca \cite{Burke:2002}.

\section{Tarefas e Conceitos}
Os Sistemas de Recomendação possuem objetivos que as aplicações implementam em comum. \citeonline{Ricci:2011} sintetizam alguns desses objetivos, que são: aumentar o número de itens vendidos, vender mais itens diferentes, aumentar a satisfação dos usuários, aumentar a fidelidade dos membros e entender melhor o desejo dos nossos usuários. Estes objetivos são adaptados ou reformulados de acordo com o domínio da aplicação. Por exemplo, uma loja eletrônica deseja vender mais itens assim como vender itens diferentes, entretanto um serviço de transmissão de filme não vende o item, mas deseja que seus usuários tenham contato com o maior número possível de seus itens disponíveis.

\citeonline{Herlocker:2004} apresentam onze tarefas que os Sistemas de Recomendação devem implementar: encontrar alguns bons itens, encontrar todos os bons itens, entender o contexto, recomendação em sequência, recomendação em grupo, navegação entre os itens, recomendação confiável, melhorar o perfil do usuário, permitir a expressividade do usuário, ajudar os usuários e por fim influenciar os outros usuários.

Os objetivos citados por \citeonline{Ricci:2011} e as tarefas descritas por \citeonline{Herlocker:2004} não são os únicos pontos que os sistemas de recomendação devem atacar. \citeonline{McNee:2006} alertam que apenas atingir o objetivo de recomendar não é o bastante e que os sistemas de recomendação devem visar outros aspectos. Assim, as pesquisas posteriores trouxeram aspectos como: diversidade na recomendação, surpresa ao usuário com um item não esperado, justiça com suas preferências, itens que tragam novidade, utilidade do item para o usuário, cobertura, dentre outros. A Figura \ref{fig:user_satiscation_component} demonstra o que é necessário e/ou desejado para a satisfação do usuário de acordo com \citeonline{Silveira:2017} que realizam um apanhado de como medir o quão bom o sistema de recomendação é.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.6]{Imagens/2-Sistemas_de_Recomendacao/Componentes_de_satisfacao.png}
    \caption{Componentes para a satisfação do usuário \cite{Silveira:2017}.}
    \label{fig:user_satiscation_component}
\end{figure}

De acordo com \citeonline{Ricci:2011} os sistemas de recomendação utilizam basicamente três tipos de dados para suprir seu objetivo: itens, usuários e relações dos usuários com os itens, chamados de transações.

\begin{itemize}
	\item{\textbf{Itens}: São os objetos a serem recomendados. Podem ser caracterizados por sua complexidade, por seu valor e/ou utilidade. O valor do item pode ser positivo caso ele seja útil para o usuário, ou negativo caso seja inapropriado. Itens podem ser representados utilizando várias abordagens de representação e informação. Em aplicações como o Netflix\footnote{https://www.netflix.com}, o item é o filme que será recomendado; no Spotify\footnote{https://www.spotify.com} o item é uma música; no Coursera\footnote{https://www.coursera.org/} o item é um curso; na Amazon\footnote{https://www.amazon.com.br/} o item é um produto (livro, eletrônico, etc). Em nosso trabalho, formalmente o conjunto de itens do sistema é representado pela letra $I$, onde um item qualquer é representado pela letra $i$ ou $j$.}

	\item{\textbf{Usuários}: Possuem diversos objetivos e características. Para realizar a personalização das recomendações, os sistemas de recomendação utilizam um conjunto de dados sobre o usuário. Esses dados podem ser estruturados de várias maneiras, e a seleção de quais dados utilizar depende da técnica de recomendação e da necessidade do domínio da aplicação. Em nosso trabalho, formalmente o conjunto dos usuários ativos do sistema é representado pela letra $U$, onde um usuário qualquer é representado pela letra $u$ ou $v$.}

	\item{\textbf{Transações}: São registros das interações entre os usuários e os itens do sistema. São dados estruturados que armazenam informações importantes geradas durante a interação do usuário com o sistema, os quais são usados pelos algoritmos recomendadores para encontrar recomendações úteis. Em nosso sistema, formalmente todas as transações dos usuários $u \in U$ com os itens $i \in I$ são representadas pela letra $T$, onde uma transação de um usuário $u$ com um item $i$ é representado como $t_{ui}$.}
\end{itemize}

\section{Modelagem do Usuário}
A realização das tarefas de um sistema de recomendação está diretamente ligada aos usuários e para isso os dados dos usuários devem estar devidamente moldados e estruturados. Entretanto, para modelar estes dados é necessário que eles sejam previamente coletados pelo sistema. Durante a interação do usuário com o sistema as transações são registradas e servem como base de dados para a modelagem. De acordo com \citeonline{Ricci:2011} é possível adotar duas técnicas para coletar os dados dos usuários sobre os itens com os quais eles interagiram, em grande parte das interações os usuários podem interagir positivamente com o item ou interagir negativamente com o item. \citeonline{Isinkaye:2015} apresentam uma terceira forma de coletar os dados de retorno dos usuários.

\subsection{Feedback Explícito}
Quando o sistema requer do usuário um retorno direto na avaliação de um item, questionando-o sobre a relevância deste, diz-se que este tipo de \textit{feedback} é explícito. Este tipo de retorno do usuário ajuda o sistema a entender o quão interessante ou relevante o item foi para o usuário.

\citeonline{Ricci:2011, Celma:2008} apresentam formas de obter o \textit{feedback} explícito do usuário. O uso do \textit{feedback} binário é uma das formas de entender a relevância do item para o usuário como o positivo/negativo (\textit{like/dislike}). O uso de \textit{feedback} discreto com valores a partir de 0 abre uma maior possibilidade de avaliação sobre o interesse do usuário. Uma possibilidade de valores é a escala Likert \cite{Lucian:2016}. Uma outra forma de obter um retorno direto do usuário é requisitar a escrita de comentários ou opiniões sobre o item.

A aplicação da técnica de \textit{feedback} explícito pode requerer do usuário mais de um tipo de interação simultânea, por exemplo, a Figura \ref{fig:steam_feedback} demonstra que a loja de jogos eletrônicos Steam requisita do usuário tanto o retorno binário quanto o retorno por comentário.

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/steam_feedback.png}
    \caption{\textit{Feedback} explícito binário e por comentário.}
    \label{fig:steam_feedback}
\end{figure}

\subsection{Feedback Implícito}
De acordo com \citeonline{Celma:2008} ``um sistema de recomendação pode inferir as preferências dos usuários a partir de monitoramento passivo das ações". \citeonline{Ricci:2011} afirmam que ``o \textit{feedback} implícito não requer qualquer ação que envolva o usuário, levando em conta que o \textit{feedback} é derivado do monitoramento e análise das atividades dos usuários". 

O método do \textit{feedback} implícito é baseado em atribuir um valor de relevância para uma ação do usuário sobre um item, como: salvar, descartar, imprimir, marcar, movimento do mouse, tempo em uma página, dentre outros. Assim, a quantidade de dados que pode ser coletada durante a interação do usuário com o sistema é grande. Entretanto, equívocos na interpretação dos dados podem vir a acontecer, por exemplo, ao usuário clicar sem querer em uma URL ou esquecer o reprodutor de música tocando um álbum que não o agrade. 

A Figura \ref{fig:kabum_feedback} demonstra a recomendação de roteadores para o usuário, após o mesmo realizar uma busca por marcas de roteadores. Assim, o sistema de recomendação entendeu que durante as próximas pesquisas o usuário possui a intenção de buscar por mais roteadores. 

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/kabum_router.png}
    \caption{\textit{Feedback} implícito a partir de uma busca textual.}
    \label{fig:kabum_feedback}
\end{figure}

\subsection{Feedback Híbrido}
De acordo com \citeonline{Isinkaye:2015} a força dos dois \textit{feedbacks} explícito e implícito pode ser combinada em um \textit{feedback} híbrido, visando minimizar a fraqueza e os erros que cada \textit{feedback} pode conter, possibilitando assim um melhor desempenho do sistema. A Figura \ref{fig:spotify_feedback} demonstra um \textit{feedback} híbrido, onde o usuário pode dar retorno positivo (botão de coração à esquerda) ou negativo (botão de cancelar à direita), além do sistema considerar quantas vezes o usuário ouviu uma determinada música.

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/spotify_hybrid_feedback.png}
    \caption{\textit{Feedback} híbrido, usando o retorno binário e o retorno de quantas vezes se ouviu a música.}
    \label{fig:spotify_feedback}
\end{figure}

\subsection{Representação dos dados}
Com os dados coletados e modelados, sendo \textit{feedback} explícito ou implícito, o sistema está apto a iniciar a fase de estudos dos dados para encontrar as recomendações. Apresentamos na Tabela \ref{tab:formal_user_item_transactions} a representação formal dos dados estruturados. Os \textit{feedbacks} são obtidos a partir das transações do sistema, sendo assim eles são modelados de forma diferente.

\begin{table}[htb!]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|l|}
\hline
$U$      & Conjunto de todos os usuários                                                                      & $u, v$   & Um usuário qualquer                                                                                    \\ \hline
$I$      & Conjunto de todos os itens                                                                         & $i, j$   & Um item qualquer                                                                                       \\ \hline
$T$      & Conjunto de todas as transações                                                                    & $t$      & Uma transação qualquer                                                                                 \\ \hline
$t_u$    & Todas as transações de $u$                                                                         & $t_i$    & Todas as transações de $i$                                                                             \\ \hline
$t_{ui}$ & Transação de $u$ com $i$                                                                           & $|T|$    & Número referente ao tamanho do conjunto $T$                                                            \\ \hline
$|U|$    & Número referente ao tamanho do conjunto $U$                                                        & $|I|$    & Número referente ao tamanho do conjunto $I$                                                            \\ \hline
$R$      & Conjunto de todos os \textit{feedbacks} válidos                                                                      & $|R|$    & Número referente ao tamanho do conjunto $R$                                                            \\ \hline
$R(u)$   & Todos os \textit{feedbacks} do usuário $u$                                                                  & $R(i)$   & Todos os \textit{feedbacks} do item $i$                                                                         \\ \hline
$\hat{R}$ & Conjunto de todos os \textit{feedbacks} preditos       & $|\hat{R}|$    & Número referente ao tamanho do conjunto $\hat{R}$                         \\ \hline
$r_{ui}$  & \begin{tabular}[c]{@{}l@{}}Valor do \textit{feedback} do usuário $u$\\ ao item $i$\end{tabular} & $\hat{r}_{ui}$ & \begin{tabular}[c]{@{}l@{}}Valor predito pelo recomendador do usuário\\ $u$ ao item $i$\end{tabular} \\ \hline
$r_{u}$  & Valores de todos os \textit{feedbacks} do usuário $u$                                                               & $r_{i}$  & Valores de todos os \textit{feedbacks} do item $i$                                                                      \\ \hline
\end{tabular}%
}
\caption{Representação formal dos conjuntos de dados utilizados pelo sistema.}
\label{tab:formal_user_item_transactions}
\end{table}

Na Seção \ref{sec:data_model} são apresentadas diversas modelagens dos dados que seguem a especificidade do domínio deste trabalho.

\section{Técnicas de Recomendação}
\label{sec:recommendation_techniques}
A partir das preferências dos usuários modeladas pelo tipo de \textit{feedback} da aplicação, os sistemas de recomendação aplicam técnicas que visam selecionar os melhores itens para seus usuários. Cada técnica trabalha de uma forma específica e possui diversos algoritmos recomendadores, os quais selecionam diferentes itens para compor as listas. Assim, dependendo do domínio, além do estudo da técnica adequada é necessário estudar qual o melhor algoritmo.

As principais técnicas de recomendação, as quais descrevemos durante as próximas seções, são: Filtragem Baseada em Conteúdo, Filtragem Colaborativa e Filtragem Híbrida. Entretanto, estas não são as únicas técnicas existentes. \citeonline{Burke:2002} faz um levantamento de diversas técnicas de recomendação existentes além das três principais, como: baseada em demografia, baseada em utilidade e baseada em conhecimento. Outros estudos também reforçam o conhecimento sobre as diversas técnicas de recomendação, como \citeonline{Ricci:2011} e \citeonline{Celma:2008}. A Tabela \ref{tab:recommendation_tecniques} apresentada no trabalho de \citeonline{Burke:2002} é um resumo sobre algumas técnicas de recomendação.

\begin{table}[htb!]
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|l|l|l|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Técnicas}} & \multicolumn{1}{c|}{\textbf{Modelagem}}                                                                                              & \multicolumn{1}{c|}{\textbf{Entrada}}                                                                                                       & \multicolumn{1}{c|}{\textbf{Processo}}                                                                                                                                              \\ \hline
    Colaborativa                            & \textit{Feedbacks} de todos os usuários                                                                                                        & \begin{tabular}[c]{@{}l@{}}\textit{Feedbacks} do usuário em processamento \\ sobre os itens de sua preferência\end{tabular}                            & \begin{tabular}[c]{@{}l@{}}Identifica os usuários similares\\ ao usuário em processamento e \\ utiliza seus \textit{feedbacks} \\ para recomendar os itens\end{tabular}                      \\ \hline
    Conteúdo                                & Dados dos itens                                                                                                                      & \begin{tabular}[c]{@{}l@{}}\textit{Feedbacks} do usuário em processamento\\ sobre os itens de sua preferência\end{tabular}                           & \begin{tabular}[c]{@{}l@{}}Molda um classificador adequado \\ ao seu comportamento de classificação\\ e o usa para selecionar os itens.\end{tabular}                                \\ \hline
    Demografia                              & \begin{tabular}[c]{@{}l@{}}Informação demográfica dos usuários\\ e seus \textit{feedbacks}\end{tabular}                                       & \begin{tabular}[c]{@{}l@{}}Informações demográficas do usuário \\ em processamento\end{tabular}                                             & \begin{tabular}[c]{@{}l@{}}Identifica os usuários que são demograficamente\\ similares ao usuário em processamento\\ e utiliza seus \textit{feedbacks} para recomendar os itens\end{tabular} \\ \hline
    Utilidade                               & Dados dos itens                                                                                                                      & \begin{tabular}[c]{@{}l@{}}Uma função de utilidade sobre os itens\\ que descreva as preferências do usuário\\ em processamento\end{tabular} & \begin{tabular}[c]{@{}l@{}}Aplica a função nos itens\\ e determina quais itens farão parte do ranque\end{tabular}                                                                   \\ \hline
    Conhecimento                            & \begin{tabular}[c]{@{}l@{}}Dados dos itens.\\ Conhecimento de como esses itens \\ atendem às necessidades de um usuário\end{tabular} & \begin{tabular}[c]{@{}l@{}}Descrição das necessidades ou dos interesses\\ do usuário em processamento\end{tabular}                          & \begin{tabular}[c]{@{}l@{}}Infere uma correspondência entre o item\\ e o usuário em processamento\end{tabular}                                                                       \\ \hline
    \end{tabular}%
    }
\caption{Técnicas de recomendação, suas modelagens, entradas e processamento \cite{Burke:2002}.}
\label{tab:recommendation_tecniques}
\end{table}

\section{Filtragem Baseada em Conteúdo}
Uma das técnicas amplamente usadas é a Filtragem Baseada em Conteúdo. Esta técnica baseia-se nos dados que compõem os itens para encontrar itens similares com as preferências dos usuários. \citeonline{Adomavicius:2005} afirmam que o método baseado em conteúdo tem sua origem nas pesquisas de recuperação da informação. De acordo com \citeonline{Ricci:2011} ``sistemas de recomendação que usam filtragem baseada em conteúdo tentam recomendar itens similares com aqueles que os usuários preferiram no passado". \citeonline{Isinkaye:2015} definem que ``a técnica baseada em conteúdo é um algoritmo dependente de domínio e enfatiza mais a análise dos atributos dos itens para gerar previsões".

Os sistemas que implementam a técnica de filtragem baseada em conteúdo analisam os metadados que constituem os itens, formando uma estrutura de informação que é utilizada durante o processo de recomendação. Este processo baseia-se no uso dos metadados dos itens das preferências de um usuário para então encontrar novos itens que possuem conteúdos similares e por fim ranqueia estes itens em uma lista de recomendação, levando em conta o quão similar este novo item é com os itens nas preferências.

De acordo com \citeonline{Lops:2011}, ``o processo de recomendação consiste em comparar os atributos do modelo do usuário com os atributos de um item. O resultado é um julgamento de relevância que representa os níveis de interesse do usuário naquele item". 

Como exemplo, na Figura \ref{fig:cbf_music} o usuário ouviu quatro músicas: ``Bolso Nada"~ de Francisco el Hombre, ``Mensageiro da Desgraça"~ dos Titãs, ``Desmascarando sua Bandeira"~ dos Flicts e ``O Calibre"~ dos Paralamas do Sucesso; e foi recomendado com ``Brasileiro"~ do Selvagens à Procura de Lei. Esta recomendação acontece devido ao conteúdo dos itens possuírem similaridades, como: o gênero musical, regravações em comum, locais e eventos de apresentação e participação em músicas em álbuns em comum.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.8]{Imagens/2-Sistemas_de_Recomendacao/CBF-Music.png}
    \caption{Exemplo de recomendação de músicas baseando-se no conteúdo que descreve os itens.}
    \label{fig:cbf_music}
\end{figure}

\subsection{Arquitetura}
De acordo com \citeonline{Lops:2011} os sistemas de recomendação ``necessitam de técnicas apropriadas para a representação dos itens e produção do perfil do usuário, e alguma estratégia para comparação do perfil do usuário com a representação do item". Em seu trabalho os autores desenvolvem uma arquitetura conceitual de alto nível para os sistemas de recomendação que visam implementar a filtragem baseada em conteúdo. A Figura \ref{fig:framework_content_based} representa a arquitetura conceitual, esta que é explanada nos tópicos abaixo.

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/Arquitetura_baseada_em_conteudo.png}
    \caption{Representação conceitual de alto nível para sistemas de recomendação baseada em conteúdo \cite{Lops:2011}.}
    \label{fig:framework_content_based}
\end{figure}

\begin{itemize}
	\item{\textbf{Base(s) de dados}: A fonte de informação utilizada pelo sistema de recomendação. Em alguns casos, o sistema pode utilizar mais de uma base de dados, como exemplo, trabalhos podem utilizar o Linked Open Data~ \cite{Bizer:2009} como fonte de dados extra para aumentar a quantidade e a qualidade das informações que são usadas no sistema. Após conectar os dados das diversas fontes, as descrições e/ou metadados dos itens servem como entrada para o analisador de conteúdo;
	}

	\item{\textbf{Analisador de conteúdo}: \citeonline{Lops:2011} afirmam que ``quando a informação não encontra-se estruturada, uma etapa de pré-processamento é necessária para extrair informações relevantes estruturadas". Esta etapa é comum em diversas áreas como: Aprendizado de Máquina, Recuperação de Informação e Engrenagens de Busca. É possível que após esta etapa algumas informações dos itens sejam removidas por não adicionarem relevância ao item ou prejudicar o aprendizado do perfil;
	}

	\item{\textbf{Representação dos itens}: \citeonline{Lops:2011} explanam que ``a principal responsabilidade deste componente é a representação do conteúdo dos itens". Após receber os dados analisados e filtrados é necessário modelar os dados de forma que o sistema de recomendação possa trabalhar de forma homogênea. Existem diversas formas de representar os dados, a mais utilizada é a vetorização das palavras, ou seja, cada palavra importante do conteúdo é representada como uma posição no vetor;
	}
	
	\item{\textbf{Aprendizado do perfil}: ``Este módulo coleta os dados representativos das preferências do usuário e tenta generalizar, para construir o perfil do usuário"~ \cite{Lops:2011}. Este perfil é utilizado pelos algoritmos recomendadores, normalmente usam-se abordagens de aprendizado de máquina. Por exemplo, \citeonline{Hijikata:2006} utilizam uma Árvore de Decisão; \citeonline{Oord:2013} implementam uma rede neural convolucional. Entretanto, nem sempre é necessário o uso de aprendizado de máquina, por exemplo, o trabalho de \citeonline{diego:2020} que implementam um algoritmo recomendador utilizando a similaridade de cosseno combinada com a frequência do termo;
	}
	
	\item{\textbf{Perfis}: Após aprender sobre o perfil do usuário, o algoritmo recomendador possui um entendimento sobre as preferências do mesmo e que é usado para encontrar novos itens;
	}
	
	\item{\textbf{Componente de filtragem}: ``Este módulo explora o perfil do usuário sugerindo itens relevantes através da comparação da representação do perfil e os itens que podem ser recomendados" ~\cite{Lops:2011}. As aplicações utilizam dos algoritmos recomendadores para filtrar a grande massa de itens que normalmente eles possuem, assim este componente é de alta importância;
	}
	
	\item{\textbf{Lista de recomendação}: Após o componente de filtragem selecionar os itens a lista de recomendação é formada com os itens mais similares ao perfil do usuário;
	}
	
	\item{\textbf{Usuário ativo e \textit{Feedback}}: Com a lista de recomendação entregue ao usuário, o mesmo julgará quais itens são relevantes a partir do \textit{Feedback}. Este retorno que o usuário dará para o sistema é incorporado ao seu perfil, tornando o algoritmo recomendador mais preciso com o tempo.
	}
\end{itemize}

\subsection{Vantagens e Problemas}
Os sistemas de recomendação que utilizam filtragem baseada em conteúdo apresentam vantagens e problemas como todas as outras técnicas. Os prós e contras do uso da técnica são apresentados nos estudos de \citeonline{Isinkaye:2015, Lops:2011, Adomavicius:2005}.

As vantagens do uso desta técnica incluem:
\begin{itemize}
    \item \textbf{Rápida adaptação}: Adaptação das recomendações caso as preferências do usuário passem por alterações, sendo essas alterações grandes ou pequenas;
    
    \item \textbf{Perfil pequeno}: Recomendação de novos itens mesmo que o usuário não possua muitos itens em seu perfil ou não contribua com uma quantidade significativa de \textit{feedbacks};
    
    \item \textbf{Privacidade}: Devido aos perfis dos usuários serem analisados separadamente sem interferências dos perfis de outros usuários. A técnica mantém seus usuários protegidos contra ataques, por exemplo, o ataque de xelim;
    
    \item \textbf{Segurança:} Dependendo da arquitetura do sistema é possível processar cada usuário separadamente, mantendo as informações do processamento somente de um usuário específico, diminuindo assim a chance de vazamento de dados;
    
    \item \textbf{Explanabilidade}: Os passos executados pelos algoritmos para encontrar a lista de itens são fáceis de serem auditados e entendidas.
\end{itemize}

A técnica também possui desvantagens, estas que incluem:
\begin{itemize}
    \item \textbf{Super especialização}: Os itens recomendados possuem o máximo de similaridade com os itens no perfil do usuário, itens externos às preferências normalmente não entram na lista de recomendação, levando o usuário a viver em uma bolha de preferências;
    
    \item \textbf{Dependência de informação}: Os itens necessitam de metadados que os descrevem, quanto menos informações mais imprecisa a recomendação é, assim a descrição dos itens precisa ser bem estruturada e rica em dados;
    
    \item \textbf{Novo usuário}: Mesmo a técnica recomendando itens para perfis com poucos \textit{feedbacks} quando um usuário não possui nenhum item em seu perfil, o sistema não consegue encontrar recomendações personalizadas. Este problema é conhecido como partida a frio.
\end{itemize}

\section{Filtragem Colaborativa}
\label{sec:collaborative_filtering}
Uma das técnicas mais utilizadas tanto em pesquisas quanto na indústria é a filtragem colaborativa. Ela toma como base os \textit{feedbacks} de todos os usuários para recomendar novos itens para um outro usuário, levando em conta o histórico de preferências deste. A técnica leva em conta somente os \textit{feedbacks} não dependendo assim do conteúdo dos itens ou informações extras dos usuários. \citeonline{Ricci:2011} afirmam que ``esta abordagem recomenda para um usuário ativo os itens que outros usuários com gostos similares gostaram no passado". \citeonline{Burke:2002} indica que ``recomendadores colaborativos agregam classificações ou objetos de recomendação, reconhecendo pontos em comum entre os usuários tomando como base as suas classificações, e gerando novas recomendações baseadas na comparação inter usuários".

``É provável que a classificação de $u$ para um novo item $i$ seja semelhante à de outro usuário $v$, se $u$ e $v$ classificaram outros itens de maneira semelhante. Da mesma forma, é provável que $u$ classifique dois itens $i$ e $j$ de maneira semelhante, se outros usuários tiverem classificações semelhantes a esses dois itens"~ \cite{Desrosiers:2011}.

Por exemplo, a Figura \ref{fig:cf_music} demonstra uma possibilidade de recomendação utilizando a técnica de filtragem colaborativa. As preferências apresentadas são de três usuários sobre cinco músicas, estas que são: ``Bolso Nada", ``Los Idiotas", ``Inútil", ``Menino Mimado"~ e ``Tá?". Dois dos três usuários possuem classificações positivas de todas as cinco músicas e o terceiro usuário ainda não conhece ``Bolso Nada"~ e ``Los idiotas", mas possui classificações semelhantes para as três outras músicas, assim este terceiro usuário será recomendado com estas duas músicas. Existe uma sexta música na figura chamada ``Brasileiro", entretanto ela não entra nas recomendações, devido a nenhum dos usuários possuir classificações positivas sobre a mesma.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.8]{Imagens/2-Sistemas_de_Recomendacao/Colaborativo.png}
    \caption{Exemplo de recomendação de músicas baseando-se nas preferências dos usuários.}
    \label{fig:cf_music}
\end{figure}

Os algoritmos da técnica são divididos em dois grupos: método baseado em memória e o método baseado em modelo~ \cite{Ricci:2011, Isinkaye:2015}. Um terceiro método pode ser caracterizado, este que se atém a formas básicas de filtragem e ordenação dos dados. Os algoritmos não são baseados em modelo ou memória. A seguir descrevemos as características de cada método:

\begin{itemize}
    \item \textbf{Método baseado em memória}: Em alguns estudos é chamada de método baseado em vizinhança ou método baseado em heurística. Usa diretamente as classificações dos usuários para encontrar outros vizinhos que possuam classificações semelhantes. Este método pode ser implementado de duas formas: i) baseando-se no usuário e ii) baseando-se no item. i) Ao implementar o caminho baseado no usuário o sistema calcula a similaridade das classificações entre um usuário $u$ e os demais usuários, buscando usuários que possuam o maior grau de similaridade. Ao encontrar os vizinhos (usuários) mais similares, os itens das preferências destes são usados como base das recomendação a $u$. ii) Os algoritmos baseados no item buscam classificações similares entre os itens, a partir de um determinado item $i$ nas preferências de $u$ são encontrados itens que possuam similaridade nas classificações. Na Seção \ref{sec:knn_algos} apresentamos uma variação do algoritmo \ac{KNN} baseado no usuário e outra baseada no item.
    
    \item \textbf{Método baseado em modelo}: Utiliza algoritmos de aprendizado de máquina para entender o perfil do usuário. O aprendizado do perfil é pré-computado e mantido no sistema o que facilita o processo de recomendação, entretanto é necessário um período de aprendizado. O método baseado em modelo analisa a relação usuário-item para encontrar novos itens. Este método consegue trabalhar com esparsidade melhor que o método em memória. Os aprendizados utilizados podem ser desde os probabilísticos, fatorizadores de matrizes, redes neurais, dentre outros.
    
    \item \textbf{Método básico}: Utiliza formas simples de filtragens e ordenação dos itens. Alguns algoritmos não trabalham com personalização, outros apenas recomendam itens com os quais o usuário ainda não teve contato, tomando com base valores globais.
\end{itemize}

A Tabela \ref{tab:cf_methods} apresenta um resumo sobre os métodos, os grupos e os algoritmos utilizados em nosso trabalho. Nas próximas seções apresentamos os algoritmos da tabela, assim como as representações formais de cada um deles.

\begin{table}[hbt!]
\begin{tabular}{|l|l|l|}
\hline
\textbf{Métodos}                             & \textbf{Grupos}     & \textbf{Algoritmos}                                                \\ \hline
\textbf{Básicos}                             & Básicos             & \begin{tabular}[c]{@{}l@{}}Popularidade\\ Melhor nota\end{tabular} \\ \hline
\multirow{2}{*}{\textbf{Baseado em memória}} & Usuário             & User-KNN                                                           \\ \cline{2-3} 
                                             & Item                & Item-KNN                                                           \\ \hline
\multirow{3}{*}{\textbf{Baseado em modelo}}  & Agrupamento         & Co Clustering                                                      \\ \cline{2-3} 
                                             & Fatoração de Matriz & \begin{tabular}[c]{@{}l@{}}SVD\\ SVD++\\ BMF\end{tabular}          \\ \cline{2-3} 
                                             & Slope One           & Slope One                                                          \\ \hline
\end{tabular}
\centering
\caption{Métodos, grupos e algoritmos da técnica de filtragem colaborativa.}
\label{tab:cf_methods}
\end{table}

\subsection{Básicos}
\label{sec:base_algos}
Vamos apresentar dois algoritmos que não são baseados em memória ou modelo. Estes que são utilizados na filtragem e ordenação de itens e são fáceis de implementar e de compreender. 

\subsubsection{Popularidade} É um algoritmo bastante usado na ordenação de itens e é comumente encontrado nos sistemas. Este simples algoritmo baseia-se em contar em quantos perfis determinado item está presente, ou seja, quantos usuários preferiram este item. A Equação \ref{eq:popularity_count} demonstra formalmente a contagem dos itens, para todos os itens $i \in I$ é contado quantas vezes esse item aparece nos \textit{feedbacks} $(|R(i)|)$. A Equação \ref{eq:popularity} demonstra formalmente a recomendação, a partir dos itens contados são retirados os itens que o usuário já conhece, mantendo assim apenas os itens desconhecidos pelo mesmo. 

\begin{equation}
    \label{eq:popularity_count}
    popI = (\forall i \in I) |R(i)|
\end{equation}

\begin{equation}
    \label{eq:popularity}
    pop(u) = popI - R(u)
\end{equation}

\subsubsection{Melhor nota} Resume os \textit{feedbacks} dos usuários sobre um determinado item, normalmente é realizada uma média dos valores dos \textit{feedbacks}. Assim, são recomendados os itens com os melhores \textit{feedbacks} que o usuário ainda não conheça. A Equação \ref{eq:sum_best_score} demonstra formalmente que para todo $i \in I$ uma média dos \textit{feedbacks} $\mu_i$ é realizada. A Equação \ref{eq:best_score} demonstra que a partir dos itens com a média realizada são removidos os itens que o usuário já conhece, restando assim somente os itens desconhecidos.

\begin{equation}
    \label{eq:sum_best_score}
    countBS = (\forall i \in I) \mu_i
\end{equation}

\begin{equation}
    \label{eq:best_score}
    bs(u) = countBS - R(u)
\end{equation}

\subsection{KNN}
\label{sec:knn_algos}
Os métodos de recomendação baseados em memória, também conhecidos como baseados em vizinhança, utilizam os \textit{feedbacks} dos usuários, buscando encontrar o grau de similaridades entre os vizinhos, quanto maior o nível de similaridade mais próximos esses vizinhos estão. Este método é dividido em dois grupos: o que verifica a similaridade entre os usuários e o grupo que verifica similaridade entre os itens. Um dos recomendadores baseados em vizinhança mais utilizados é o \ac{KNN}. \citeonline{Desrosiers:2011} e \citeonline{Koren:2015} apresentam formulações do \ac{KNN} para os usuários e para os itens chamados de User-KNN e Item-KNN.

\subsubsection{User-KNN} Esta implementação do \ac{KNN} baseia-se em encontrar usuários com os maiores graus de similaridades. A relação de todos os usuários $u \in U$ com todos os itens $i \in I$ é modelada como uma matriz usuário-item, onde cada linha é um usuário e cada coluna é um item. Ao selecionar um usuário $u$ para encontrar as recomendações é verificado quais outros usuários possuem similaridades nos \textit{feedbacks}. O User-KNN mede o grau de similaridade entre um usuário $u$ e outro usuário $v$ através de qualquer medida de distância. A seguir apresentamos algumas das medidas de distância que baseiam-se no cálculo de distância entre vetores.

\begin{equation}
    \label{eq:person_user}
    sim(u,v) = PC(u,v) = \frac{\sum_{i \in I_{uv}}(r_{ui} - \mu_u)(r_{vi} - \mu_v)}{\sqrt{\sum_{i \in I_{uv}}(r_{ui} - \mu_u)^2\sum_{i \in I_{uv}}(r_{vi} - \mu_v)^2}}
\end{equation}

A Equação \ref{eq:person_user} é a representação formal da correlação de Person, dois usuários $u$ e $v$ são dados como entrada. Na equação $I_{uv}$ representa as posições dos vetores que por sua vez são itens. $r_{ui}$ representa o \textit{feedback} do usuário $u$ sobre o item $i$ e $r_{vi}$ do usuário $v$ sobre o item $i$. $\mu_u$ representa a média dos valores dos \textit{feedbacks} do usuário $u$ e $\mu_v$ a média do usuário $v$.

\begin{equation}
    \label{eq:cossine_user}
    sim(u,v) = cos(u,v) = \frac{\sum_{i \in I_{uv}}r_{ui}r_{vi}}{\sqrt{\sum_{i \in I_{uv}}r_{ui}^2\sum_{i \in I_{uv}}r_{vi}^2}}
\end{equation}

A Equação \ref{eq:cossine_user} é a representação formal da similaridade do Cosseno, onde dois usuários $u$ e $v$ são dados como entrada. Na equação $I_{uv}$ representa as posições dos vetores de $u$ e $v$ que por sua vez são itens $i$. $r_{ui}$ representa o valor do \textit{feedback} do usuário $u$ sobre o item $i$ e $r_{vi}$ do usuário $v$ sobre o item $i$.

\begin{equation}
    \label{eq:user_knn}
    \hat{r}_{ui} = \frac{\sum_{v \in N_{i}^{k}} sim(u,v)\cdot r_{vi}}{\sum_{v \in N_{i}^{k}} sim(u,v)}
\end{equation}

A Equação \ref{eq:user_knn} representa formalmente a predição do User-KNN de usuário sobre um item $\hat{r}_{ui}$. Onde $N_{i}^{k}$ representa os $k$ vizinhos com o maior grau de similaridade com o usuário $u$. Assim, o recomendador possui dois hiper parâmetros, o $k$ e a medida de distância.

\subsubsection{Item-KNN} Esta implementação do \ac{KNN} baseia-se em encontrar itens com os maiores graus de similaridades. A relação de todos os itens $i \in I$ por todos os itens $j \in I$ é modelada como uma matriz item-item, onde cada linha é um item e cada coluna também é um item. Ao selecionar um item $i$ para encontrar as recomendações é verificado quais outros itens possuem similaridades nos \textit{feedbacks}. O Item-KNN mede o grau de similaridade entre um item $i$ e outro item $j$ através de qualquer medida de distância. A seguir apresentamos algumas das medidas de distância que baseiam-se no cálculo de distância entre vetores.

\begin{equation}
    \label{eq:person_item}
    sim(i,j) = PC(i,j) = \frac{\sum_{u \in U_{ij}}(r_{ui} - \mu_i)(r_{uj} - \mu_j)}{\sqrt{\sum_{u \in U_{ij}}(r_{ui} - \mu_i)^2\sum_{u \in U_{ij}}(r_{uj} - \mu_j)^2}}
\end{equation}

A Equação \ref{eq:person_item} é a representação formal da correlação de Person, dois itens $i$ e $j$ são dados como entrada. Na equação $U_{ij}$ representa as posições dos vetores que por sua vez são usuários. $r_{ui}$ representa o \textit{feedback} do usuário $u$ sobre o item $i$ e $r_{uj}$ do usuário $u$ sobre o item $j$. $\mu_i$ representa a média dos valores dos \textit{feedbacks} do item $i$ e $\mu_j$ a média do item $j$.

\begin{equation}
    \label{eq:cossine_item}
    sim(i,j) = cos(i,j) = \frac{\sum_{u \in U_{ij}}r_{ui}r_{uj}}{\sqrt{\sum_{u \in U_{ij}}r_{ui}^2\sum_{u \in U_{ij}}r_{uj}^2}}
\end{equation}

A Equação \ref{eq:cossine_item} é a representação formal da similaridade do Cosseno, onde dois itens $i$ e $j$ são dados como entrada. Na equação $U_{ij}$ representa os usuários que possuem \textit{feedbacks} dos itens $i$ e $j$. $r_{ui}$ representa o valor do \textit{feedback} do usuário $u$ sobre o item $i$ e $r_{uj}$ do usuário $u$ sobre o item $j$.

\begin{equation}
    \label{eq:item_knn}
    \hat{r}_{ui} = \frac{\sum_{j \in N_{u}^{k}} sim(i,j)\cdot r_{uj}}{\sum_{j \in N_{u}^{k}} sim(i,j)}
\end{equation}

A Equação \ref{eq:item_knn} representa formalmente a predição do Item-KNN de usuário sobre um item $\hat{r}_{ui}$. Onde $N_{u}^{k}$ representa os $k$ vizinhos com o maior grau de similaridade com o item $i$. Assim, o recomendador possui dois hiper parâmetros, o $k$ e a medida de distância.

\subsection{Fatoração de Matrizes}
\label{sec:mf_algos}
Dentro dos métodos baseados em modelos existe o grupo de algoritmos que trabalham com fatoração de matrizes. A Tabela \ref{tab:cf_methods} indica três possibilidades, as quais apresentamos nesta seção, o \ac{SVD}, o \ac{SVD++} e o \ac{NMF}. \citeonline{Koren:2009} afirmam que os modelos baseados em fatoração de matrizes demonstram uma superioridade sobre os algoritmos baseados em vizinhança e afirmam também que estes algoritmos produzem uma recomendação com melhor precisão. Os recomendadores que trabalham com fatoração juntam em um fator latente de dimensionalidade $f$ os interesses dos usuários sobre os itens.

\subsubsection{SVD}
Famoso pelo seu desempenho durante o Netflix Prize\footnote{https://www.netflixprize.com/}. O recomendador logo ganhou notoriedade e se tornou um dos algoritmos de fatoração de matrizes mais utilizados. A implementação descrita por \citeonline{Koren:2015} consideram ou não o viés do usuário e do item no preditor. As Equações \ref{eq:svd_bi}, \ref{eq:svd_bu}, \ref{eq:svd_rating_wbias}, \ref{eq:svd_rating_bias}, \ref{eq:svd_rse} e \ref{eq:svd_error} descrevem formalmente o \ac{SVD}.

As Equações \ref{eq:svd_bi} e \ref{eq:svd_bu} representam formalmente o viés de um item $b_{i}$ e um usuário $b_{u}$. Onde temos que $\mu$ é a média de todos os \textit{feedbacks} dos usuários, $r_{ui}$ é o valor do \textit{feedback} do usuário $u$ sobre um item $i$. Os valor de $\alpha$ e $\sigma$ podem ser atribuídos pelo especialista do sistema ou encontrados a partir da distribuição normal, estes valores evitam a divisão por zero e são utilizados apenas no início do recomendador. $R$ representa todas as transações válidas dos usuários, sendo $R(u)$ todas as transações de $u$ e $R(i)$ todas as transações do item $i$.
\begin{equation}
    \label{eq:svd_bi}
    b_{i} = \frac{\sum_{u \in R(i)}(r_{ui}-\mu)}{\alpha+|R(i)|}
\end{equation}

\begin{equation}
    \label{eq:svd_bu}
    b_{u} = \frac{\sum_{i \in R(u)}(r_{ui}-\mu-b_i)}{\sigma+|R(u)|}
\end{equation}

As Equações \ref{eq:svd_rating_wbias} e \ref{eq:svd_rating_bias} demonstram formalmente como o \ac{SVD} prediz o valor de um usuário sobre um item. $q_{i}$ é um vetor de fatores latentes do item $i$ de dimensionalidade $f$ e $p_u$ é um vetor com a mesma dimensionalidade, entretanto o vetor de $p_u$ representa os fatores latentes do usuário $u$. A diferença entre as equações se dá devido à implementação escolhida considerar ou não o viés do usuário e do item, sendo a Equação \ref{eq:svd_rating_wbias} a que não utiliza o viés e a Equação \ref{eq:svd_rating_bias} a que utiliza. Esta escolha fica a cargo do especialista do sistema e do domínio da aplicação.

\begin{equation}
    \label{eq:svd_rating_wbias}
    \hat{r}_{ui} = q_{i}^{T}p_u
\end{equation}

\begin{equation}
    \label{eq:svd_rating_bias}
    \hat{r}_{ui} = \mu + b_i + b_u + q_{i}^{T}p_u
\end{equation}

Para entender as variáveis do modelo ($b_u$, $b_i$, $p_u$ e $q_i$), minimizamos o erro quadrado regularizado como é formalmente demonstrado na Equação \ref{eq:svd_rse} a seguir \cite{Koren:2015}.

\begin{equation}
    \label{eq:svd_rse}
    min_{b*,q*,p*}\sum_{(u,i) \in K} (r_{ui} - \hat{r}_{ui})^2 + \lambda(b_i^2 + b_u^2 + ||q_i||^2 + ||p_u||^2)
\end{equation}

A Equação \ref{eq:svd_error} demonstra o cálculo da diferença entre o \textit{feedback} real e o valor predito.
\begin{equation}
    \label{eq:svd_error}
    e_{ui} = r_{ui} - \hat{r}_{ui}
\end{equation}

Abaixo é formalmente apresentada a regulação do recomendador, onde o mesmo itera em forma de ``épocas'' e a cada nova época adapta seus valores para obter uma menor taxa de erro. O valor $\gamma$ representa a taxa de aprendizado que influencia o grau de adaptação.
\begin{itemize}
    \item $b_u = b_u + \gamma \cdot (e_{ui} - \lambda \cdot b_u)$
    \item $b_i = b_i + \gamma \cdot (e_{ui} - \lambda \cdot b_i)$
    \item $q_i = q_i + \gamma \cdot (e_{ui} \cdot p_u - \lambda \cdot q_i)$
    \item $p_u = p_u + \gamma \cdot (e_{ui} \cdot q_i - \lambda \cdot p_u)$
\end{itemize}

O recomendador \ac{SVD} possui ao todo seis hiper parâmetros. i) $\alpha$ e ii) $\gamma$ que são valores obtidos através do especialista do sistema ou da distribuição normal e são utilizados apenas no início do processo. iii) $\gamma$ que representa a taxa de aprendizado, onde a cada iteração o recomendador adiciona ou subtrai um valor regulado pelo aprendizado. iv) $\lambda$ que representa o valor de regularização dos parâmetros $b_u$, $b_i$, $p_u$ e $q_i$. v) $f$ que representa a quantidade de fatores latentes. vi) ``Épocas'' que representa quantas vezes o recomendador itera sobre os dados.

\subsubsection{SVD++}
Proposto para trabalhar também com \textit{feedback} implícito e prover informações adicionais sobre as preferências dos usuários, o \ac{SVD++} é altamente útil em sistemas aos quais os usuários proveem mais \textit{feedbacks} implícitos. \citeonline{Koren:2015} apresentam formalmente o recomendador que é uma melhoria do \ac{SVD}. A seguir descrevemos sua formulação.

A Equação \ref{eq:svdpp_rating} demonstra a primeira modificação que o \ac{SVD++} propõe sobre o \ac{SVD}. O valor predito de um usuário $u$ sobre um item $i$, leva em consideração um novo vetor de fatores latentes $y_i$ também de dimensionalidade $f$. Este novo vetor representa o entendimento do \textit{feedback} implícito a partir de uma análise do \textit{feedback} explícito.
\begin{equation}
    \label{eq:svdpp_rating}
    \hat{r}_{ui} = \mu + b_i + b_u + q_{i}^{T}(p_u + |R(u)|^{-\frac{1}{2}} \cdot \sum_{j \in R(u)}y_i)
\end{equation}

A atualização das variáveis também é modificada no \ac{SVD++} em relação ao \ac{SVD}. A formulação a seguir demonstra que na atualização dos fatores latentes $q_i$ e $p_u$ existe um novo hiper parâmetro $\delta$, além de uma adição de expressões na atualização do $q_i$. A formulação também possui a atualização do novo vetor de fatores latentes $y_i$.
\begin{itemize}
    \item $b_u = b_u + \gamma \cdot (e_{ui} - \lambda \cdot b_u)$
    
    \item $b_i = b_i + \gamma \cdot (e_{ui} - \lambda \cdot b_i)$
    
    \item $q_i = q_i + \gamma \cdot (e_{ui} \cdot (p_u + |R(u)|^{-\frac{1}{2}} \cdot \sum_{j \in R(u)}y_i ) - \delta \cdot q_i)$
    
    \item $p_u = p_u + \gamma \cdot (e_{ui} \cdot q_i - \delta \cdot p_u)$
    
    \item $\forall j \in R(u):$
    
    $y_i <- y_i + \gamma \cdot (e_{ui} \cdot |R(u)|^{-\frac{1}{2}} \cdot q_i - \delta \cdot y_i)$
\end{itemize}

O recomendador \ac{SVD++} possui sete hiper parâmetros, sendo os mesmos seis do \ac{SVD} e o novo hiper parâmetro $\delta$. Algumas implementações associam o valor de $\lambda$ ao $\delta$, \citeonline{Koren:2015} associam valores diferentes e também sugere valores não otimizados para domínios.

\subsubsection{NMF}
Um outro recomendador que pertence ao grupo de fatorizadores de matrizes é o \ac{NMF}. Este algoritmo também possui diversas variações como debatido por \citeonline{Zhang:1996} e por \citeonline{Luo:2014}. O \ac{NMF} trabalha com uma matriz não negativa possibilitando encontrar fatores latentes não negativos. \citeonline{Luo:2014} apresentam formalmente uma implementação do recomendador, a qual é apresentada a seguir. 

O \ac{NMF} segue a predição do valor do \textit{feedback} apresentado nas Equações \ref{eq:svd_rating_wbias} e \ref{eq:svd_rating_bias} igual as outras formulações dos recomendadores decompositores explanados acima, com exceção da atualização dos vetores dos fatores latentes $q_i$ e $p_u$, estes que possuem uma nova formulação.

\begin{equation}
    \label{eq:nmf_pu}
    p_u = p_u \cdot \frac{\sum_{i \in I_u}q_i \cdot r_{ui}}{\sum_{i \in I_u}q_i \cdot \hat{r}_{ui} + \lambda_u |I_u| \cdot p_u}
\end{equation}

\begin{equation}
    \label{eq:nmf_qi}
    q_i = q_i \cdot \frac{\sum_{u \in U_i}p_u \cdot r_{ui}}{\sum_{u \in U_i}p_u \cdot \hat{r}_{ui} + \lambda_i |U_i| \cdot q_i}
\end{equation}

Onde, $I_u$ representa todos os \textit{feedbacks} do usuário $u$ e $U_i$ representa todos os \textit{feedbacks} recebidos pelo item $i$. O \ac{NMF} possui ao todo oito hiper parâmetros, sendo os seis apresentados no \ac{SVD} e \ac{SVD++}, e os dois novos hiper parâmetros para controlar os vetores de fatores latentes, sendo o $\lambda_i$ para controlar o $q_i$ e o $\lambda_u$ para controlar o $p_u$.

\subsection{Slope One}
\label{sec:slope_algo}
\citeonline{Lemire:2007} apresentam o Slope One, um recomendador simples de implementar, manter e suscetível a atualizações em tempo real. Os autores afirmam que o recomendador obtém precisão idêntica a recomendadores baseados em memória. O Slope One possui implementações que são baseados em modelos e implementações baseadas em memória como apresentado por \citeonline{Lemire:2007}. Assim, na Tabela \ref{tab:cf_methods} classificamos como um algoritmo baseado em modelo, o qual apresentamos a seguir.

\begin{equation}
    \label{eq:slope_one_dev}
    dev(i,j) = \frac{1}{|U_{ij}|}\sum_{u \in U_{ij}} r_{ui} - r_{uj}
\end{equation}

\begin{equation}
    \label{eq:slope_one}
    \hat{r}_{ui} = \mu_u + \frac{1}{|R_{i}(u)|} \sum_{j \in R_{i}(u)} dev(i,j)
\end{equation}

Onde, $U_{ij}$ representa todos os usuários que possuem \textit{feedbacks} sobre o item $i$ e $j$, sendo $r_{ui}$ o \textit{feedback} do usuário $u$ sobre o item $i$ e $r_{uj}$ sobre o item $j$. $R_{i}(u)$ representa o conjunto de itens $j$ que possuem \textit{feedbacks} de $u$ que também possui pelo menos um usuário em comum com o item $i$. Por fim, $\mu_u$ representa a média dos valores dos \textit{feedbacks} do usuário $u$.

\subsection{Co-Clustering}
\label{sec:clustering_algo}
Os algoritmos de agrupamento baseiam-se em mapear itens ou usuários que possuam similaridades sob um único grupo. \citeonline{George:2005} apresentam uma implementação de um recomendador que utiliza tanto os grupos dos itens quanto os grupos dos usuários para encontrar recomendações. A seguir é apresentada a formulação. 

\begin{equation}
    \label{eq:co_lustering}
    \hat{r}_{ui} = \overline{C_{ui}} + (\mu_u  - \overline{C_{u}}) + (\mu_i  - \overline{C_{i}})
\end{equation}

A Equação \ref{eq:co_lustering} apresenta a formulação que o recomendador aplica para predizer um \textit{feedback} do usuário $u$ sobre um item $i$, que é representado por $\hat{r}_{ui}$. $\overline{C_{ui}}$ representa a média dos \textit{feedbacks} do grupo correlacionado do usuário $u$ com o item $i$. $\mu_u$ representa a média dos \textit{feedbacks} do usuário $u$. $\mu_i$ representa a média dos \textit{feedbacks} que o item $i$ recebeu. $\overline{C_{u}}$ representa a média dos \textit{feedbacks} do grupo ao qual o usuário $u$ faz parte. $\overline{C_{i}}$ representa a média dos \textit{feedbacks} do grupo ao qual o item $i$ faz parte.

O recomendador possui três hiper parâmetros: i) ``Épocas'' que representa quantas vezes o recomendador itera sobre os dados; ii) $\gamma$ que representa o tamanho do grupo de itens; iii) $\rho$ que representa o tamanho do grupo de usuários.

\subsection{Vantagens e Problemas}
Os sistemas de recomendação que implementam a técnica de filtragem colaborativa aceitam as vantagens e as desvantagens existentes na abordagem. Algumas vantagens são associadas aos métodos baseados em vizinhança e algumas são associados aos baseados em modelos, assim como para as desvantagens.

As vantagens do uso da técnicas são:
\begin{enumerate}
    \item \textbf{Simplicidade}: Os recomendadores baseados em memória são fáceis de entender, simples de implementar e adaptar~ \cite{Isinkaye:2015, Desrosiers:2011, Su:2009};
    
    \item \textbf{Justificabilidade}: As predições dos recomendadores baseados em memória possuem uma fácil e simples justificabilidade do porquê cada item está sendo recomendado~ \cite{Desrosiers:2011};
    
    \item \textbf{Eficiência}: Os recomendadores baseados em memória não necessitam de um treinamento para aprender sobre o perfil do usuário e dos seus pares. Além de utilizar somente os \textit{feedbacks}, facilitando o processamento dos dados~ \cite{Desrosiers:2011};
    
    \item \textbf{Performance}: Os recomendadores baseados em modelos possuem uma alta precisão nas recomendações~ \cite{Su:2009};
    
    \item \textbf{Estabilidade}: A técnica não é afetada por instabilidades nos perfis do usuário ou por mudanças de comportamento momentâneo, adaptando-se assim a alterações de grande impacto~ \cite{Desrosiers:2011};
    
    \item \textbf{Livre de conteúdo}: Diferente da técnica de filtragem baseada em conteúdo não se torna necessário dados sobre os itens para encontrar recomendações, assim, domínios onde as informações sobre os itens são raras esta técnica obtém melhores resultados~ \cite{Isinkaye:2015, Su:2009};
    
    \item \textbf{Acaso}: Diferente da técnica de filtragem baseada em conteúdo as abordagens trazem a possibilidade de itens fora da bolha do usuário, evitando a super especialização~ \cite{Isinkaye:2015, Desrosiers:2011}.
\end{enumerate}

As desvantagens do uso da técnica são:
\begin{enumerate}
    \item \textbf{Enviesamento}: A técnica baseia-se \textit{feedbacks} de outrem para encontrar recomendações de novos itens similares. O uso desses \textit{feedbabks} pode influenciar a técnica a encontrar recomendações que não condizem com suas preferências. Caso o usuário perceba que suas preferências não estão sendo respeitadas e passe a entender o sistema como não confiável este pode abandonar o sistema. Um dos enviesamentos mais comuns é o por popularidade, onde as recomendações podem ser compostas pelo mesmo grupo de itens populares entre os usuários mais antigos do sistema. Outro enviesamento é a sobreposição, onde um gênero de maior preferência sobrepõe um gênero de menor preferência;
    
    \item \textbf{Partida a frio}: Um dos principais problemas da técnica se refere a quando um usuário acaba de aderir a aplicação e não contribuiu com nenhum tipo de \textit{feedback}. Nesse caso, a técnica de filtragem colaborativa não consegue encontrar recomendações para o usuário~ \cite{Isinkaye:2015, Su:2009};
    
    \item \textbf{Novo item}: Um novo item ao ser cadastrado na aplicação não possui nenhum \textit{feedback} do usuário, assim a técnica não consegue encontrar o item e adicioná-lo na lista de recomendação de algum usuário que possa vir a preferir o item~ \cite{Isinkaye:2015, Su:2009};
    
    \item \textbf{Esparsidade}: Quando apenas uma pequena parte dos usuários contribuem com \textit{feedbacks}, causando uma carência de informação. O efeito da esparsidade é uma lista de recomendação fraca, devido à dificuldade de encontrar vizinhos~ \cite{Isinkaye:2015, Su:2009};
    
    \item \textbf{Escalabilidade}: A computação normalmente é feita sobre uma matriz usuário-item, onde em pequenas bases de dados obtém um bom desempenho, mas diante de uma grande massa de dados pode ser ineficiente~ \cite{Isinkaye:2015, Su:2009};
    
    \item \textbf{Sinônimo}: Ao serem cadastrados no sistema itens similares mas com nomes diferentes, estes podem não ser relacionados devido à diferença nos \textit{feedbacks} dos usuários~ \cite{Isinkaye:2015, Su:2009}.
    
    \item \textbf{Ovelha cinza}: Usuários que não se encaixam em nenhum grupo ou possuem preferências que não permitam encontrar vizinhos não recebem recomendações, devido à técnica não conseguir encontrar novos itens similares às preferências a partir de \textit{feedbacks} de outrem~ \cite{qin:2013, Su:2009}.
    
    \item \textbf{Ataque de xelim}: Um item concorrente nas recomendações pode deliberadamente alimentar o sistema com \textit{feedbacks} negativos para punir um adversário, ganhando vantagens para si e não permitindo que usuários possam receber o item adversário como recomendação~ \cite{qin:2013, Su:2009}.
    
    \item \textbf{Privacidade e Segurança}: \citeonline{Schafer:2007} apontam que ``nas arquiteturas centralizadas de filtragem colaborativa, um único repositório armazena todas as classificações de usuários. Se o servidor central ficar comprometido, corrompido ou exposto, o anonimato do usuário pode ser destruído". O mesmo problema pode acontecer em arquitetura distribuída. Assim, o uso de criptografias na técnica se torna necessário.
\end{enumerate}

\section{Filtragem Híbrida}
\citeonline{Burke:2002} em sua pesquisa elucida que ``um sistema de recomendação híbrido combina duas ou mais técnicas de recomendação para ganhar uma melhor performance com menos desvantagens que qualquer uma individual". \citeonline{Ricci:2011} explicam que ``um sistema híbrido combina técnicas A e B tentando usar as vantagens de A para consertar as desvantagens de B".

Normalmente os sistemas de recomendação híbridos combinam as técnicas de filtragem colaborativa e filtragem baseada em conteúdo. Entretanto qualquer técnica pode ser combinada, desde que satisfaça os requisitos do domínio da aplicação. Ao combinar as técnicas as desvantagens são reduzidas a partir de uma vantagem de uma outra técnica, assim combinar técnicas que cubram as desvantagens umas das outras é o melhor para se obter uma melhor precisão.

Existem diversos métodos para combinar técnicas de recomendação em uma abordagem híbrida. \citeonline{Burke:2002} em sua pesquisa mapeia algumas possibilidades de hibridização, as quais estão descritas na Tabela \ref{tab:hybrid_method}.

\begin{table}[hbt!]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
\textbf{Métodos de hibridização}       & \textbf{Descrição}                                                                                                                                                   \\ \hline
Ponderada                     & \begin{tabular}[c]{@{}l@{}}As pontuações (ou votos) de várias técnicas de recomendação \\ são combinadas para produzir uma única recomendação.\end{tabular} \\ \hline
Alternada                     & \begin{tabular}[c]{@{}l@{}}O sistema alterna entre técnicas de recomendação\\ dependendo da situação.\end{tabular}                                          \\ \hline
Mista                         & \begin{tabular}[c]{@{}l@{}}Recomendações de vários recomendadores diferentes são\\ apresentado ao mesmo tempo.\end{tabular}                                 \\ \hline
Combinação de características & \begin{tabular}[c]{@{}l@{}}Recursos de diferentes fontes de dados de recomendação\\ são reunidos em um único algoritmo de recomendação.\end{tabular}        \\ \hline
Cascata                       & Um recomendador refina as recomendações dadas por outro.                                                                                                    \\ \hline
Aumento de recursos           & \begin{tabular}[c]{@{}l@{}}A saída de uma técnica é usada como um recurso de entrada \\ para outra.\end{tabular}                                            \\ \hline
Meta-Nível                    & \begin{tabular}[c]{@{}l@{}}O modelo aprendido por um recomendador é usado como \\ entrada para outro.\end{tabular}                                          \\ \hline
\end{tabular}%
}
\caption{Métodos de hibridização~\cite{Burke:2002}.}
\label{tab:hybrid_method}
\end{table}

\section{Avaliação de Sistemas de Recomendação}
\label{sec:recommendation_system_metrics}
Nesta seção iremos debater as formas de avaliação dos Sistemas de Recomendação, como: os protocolos, as métricas e seus tipos, e a busca pelos melhores hiper parâmetros dos algoritmos.

\subsection{Protocolos de avaliação}
De acordo com \citeonline{Shani:2011} para entender o comportamento dos Sistemas de Recomendação e compará-los, existem três diferentes protocolos de avaliação: \textit{offiline}, estudos de casos dos usuários e \textit{online}. Os protocolos podem ser aplicados a qualquer técnica de recomendação e seus recomendadores. Sistemas de Recomendação que serão utilizados com usuários reais normalmente aplicam os três protocolos, buscando primeiro entender o sistema com o protocolo \textit{offline}, depois estudar o comportamento do sistema com alguns estudos de casos e por fim aplicar o protocolo \textit{online} onde uma interação com usuários reais é exigida.

\subsubsection{Offline}
\citeonline{Shani:2011} afirmam que ``o protocolo de avaliação \textit{offline} é o mais fácil de ser utilizado e não requer interação do usuário com o sistema''. Normalmente o protocolo é utilizado com um conjunto de dados pré-coletados dos usuários, itens e as transações. Esse conjunto de dados é utilizado para simular o comportamento dos usuários e o poder de predição dos algoritmos avaliados. Este protocolo nos permite filtrar comportamentos inapropriados dos algoritmos recomendadores, permitindo assim escolher o algoritmo mais adequado para o sistema. O protocolo \textit{offline} permite que estudos de enviesamento possam ser melhor desenvolvidos, assim como uma avaliação do comportamento dos usuários. Além do estudo do enviesamento, o protocolo nos permite trabalhar com diferentes modelagens dos dados, dando vez assim para um estudo de uma modelagem mais complexa e eficiente do usuário.

\subsubsection{Estudos de casos}
Sistemas de Recomendação necessitam da interação dos usuários, assim somente o protocolo \textit{offline} não é suficiente para entender o comportamento dos mesmos. Entretanto pular direto para a disponibilização do sistema \textit{online} também não é aconselhável. Neste caso, os estudos de casos são conduzidos. Este protocolo se baseia na escolha de um grupo limitado de usuários para interagir com o sistema, permitindo assim que diversos dados possam ser coletados, tanto qualitativos quanto quantitativos. Além destes dados é possível que o especialista do sistema observe determinados comportamentos que o protocolo \textit{offline} não captura. Questionários podem ser aplicados durante todo o processo de interação do usuário.

\subsubsection{Online}
De acordo com \citeonline{Shani:2011}, ``Sistemas de Recomendação realistas são produzidos para influenciarem o comportamento dos usuários, assim como identificar possíveis mudanças de comportamento ao interagir com diferentes algoritmos recomendadores''. O real desempenho de um Sistema de Recomendação ao interagir com usuários reais depende de uma variedade de fatores, sendo todos eles cruciais para a avaliação da efetividade.

\subsection{Métricas preditivas}
\label{sec:error_metrics}
As métricas preditivas desejam comparar os valores preditos com os valores reais atribuídos pelos usuários \cite{Celma:2008}. \citeonline{Herlocker:2004} afirmam que ``as métricas preditivas medem o quão perto os algoritmos recomendadores preveem os valores dos verdadeiros atribuídos pelos usuários''. Eles também afirmam que ``essas métricas são particularmente importantes para a avaliação das tarefas de predição que serão exibidas aos usuários''.

\subsubsection{MAE}
A métrica \ac{MAE} mede a média do desvio absoluto entre o valor predito e o valor original. \ac{MAE} é uma métrica comumente usada e possui diversas variações. A Equação \ref{eq:mae} é a representação formal da métrica.

\begin{equation}
    MAE = \frac{1}{|\hat{R}|}\sum_{\hat{r}_{ui} \in \hat{R}} |\hat{r}_{ui} - r_{ui}|
    \label{eq:mae}
\end{equation}

Onde $\hat{R}$ representa o conjunto das predições (usuário-item), $\hat{r}_{ui}$ representa o valor predito para um \textit{feedback} $\hat{r}_{ui} \in \hat{R}$ e $r_{ui}$ representa o valor original do \textit{feedback}. Assim, é aplicado um somatório da diferença entre o predito e o real, e ao final uma média é feita.

\subsubsection{RMSE}
A métrica \ac{RMSE} é uma das mais populares e utilizadas em todos os protocolos de avaliação, assim como é utilizada por diversos Sistemas de Recomendação comerciais. Ela é uma variação da \ac{MAE}, onde a diferença entre o predito e o original é elevada ao quadrado, assim como após obter a média do somatório é aplicada uma raiz ao valor. A Equação \ref{eq:rmse} é a representação formal da métrica.

\begin{equation}
    RMSE = \sqrt{\frac{1}{|\hat{R}|}\sum_{\hat{r}_{ui} \in \hat{R}} (\hat{r}_{ui} - r_{ui})^2}
    \label{eq:rmse}
\end{equation}

\subsection{Métricas de ranque}
\label{sec:rank_metrics}
Normalmente os Sistemas de Recomendação  entregam aos usuários uma lista de tamanho N contendo os top-N itens mais indicados para o determinado usuário ou grupo. Assim, para quantificar a qualidade da lista as métricas de ranque são aplicadas. A seguir, apresentaremos duas das mais usadas.

\subsubsection{MAP}
A fim de obter uma métrica única que contribui para a precisão do método de recomendação ao longo de todo o conjunto de usuários, utiliza-se o \ac{MAP} \cite{Parra:2013}. O valor do \textit{\ac{MAP}} é obtido calculando a média sobre a precisão média da lista de recomendações de cada usuário.

\begin{equation}
    \label{eq:map}
    MAP = \frac{1}{|U|}\sum_{u}^{U}AveP(u)
\end{equation}

\begin{equation}
    \label{eq:ap}
    AveP(u) = \frac{1}{N}\sum_{i=1}^{N}p@i
\end{equation}

\begin{equation}
    \label{eq:p@i}
    p@i = \frac{r}{i}
\end{equation}

Na Equação \ref{eq:map}, $AveP(u)$ é a média da precisão para o usuário $u \in U$, isto é, a média dos valores da precisão obtidos para o conjunto de top-N recomendações depois que cada sugestão relevante é recuperada \cite{Manning:2008}. As Equações \ref{eq:ap} e \ref{eq:p@i} mostram os cálculos da média da precisão, que é uma soma da precisão em cada posição da lista $p@i$ onde $r$ é a quantidade de músicas relevantes até a posição $i$.

\subsubsection{MRR}
A métrica \ac{MRR} avalia a qualidade das listas de recomendação, medindo o quão longe o primeiro item relevante está do topo da lista \cite{qin:2013}. Na Equação \ref{eq:mrr} é possível verificar a formulação do \ac{MRR} onde $\forall u \in U$  a primeira ocorrência de uma recomendação relevante $p_{i}$ é avaliada.

\begin{equation}
    MRR = \frac{1}{|U|}\sum_{u}^{U}\frac{1}{p_{i}}
    \label{eq:mrr}
\end{equation}

% \subsection{Grid Search}
% \label{sec:grid_search}
% A maioria dos algoritmos recomendadores possuem valores atribuídos manualmente pelo especialista do sistema. Neste trabalho, chamamos estes valores de hiper parâmetros. Eles servem para adaptar o algoritmo ao domínio e à base de dados, obtendo uma melhor precisão dependendo do valor ou da combinação de valores escolhidos. 

% O \textit{Grid Search} realiza uma busca extensiva pela melhor combinação de hiper parâmetros a partir de um conjunto de valores atribuídos pelo especialista do sistema. Por exemplo, os algoritmos baseados no KNN possuem dois hiper parâmetros, sendo um deles o valor de \textit{k} (3, 5, 7, 11) e o outro qual medida de distância será usada (cosseno, person, manhattan). Neste exemplo, o \textit{grid search} aplicaria todas as combinações possíveis, totalizando 12 execuções do sistema. Para definir qual dessas é a melhor combinação uma métrica necessita ser atribuída, sendo que esta será utilizada para comparar os resultados e selecionar a melhor combinação.

\section{Aplicações Industriais de Sistemas de Recomendação}
Atualmente os Sistemas de Recomendação fazem parte dos nossos dias, estando presentes em: lojas eletrônicas indicando qual item comprar a partir de compras anteriores, transmissão de vídeo ou música onde o que se assistiu ou ouviu serve como base para recomendação de novos itens, cursos pela Internet que recomendam novas classes a partir de cursos previamente terminados. A seguir iremos nomear alguns desses sistemas industriais.

\subsection{Last.fm}
Um dos primeiros serviços de transmissão de música pela Internet, o Last.fm\footnote{https://www.last.fm/} foi criado em 2002 no Reino Unido e até junho de 2020 possuía mais de 121 bilhões de faixas musicais reproduzidas. Inicialmente o sistema foi desenvolvido para a descoberta de músicas a partir de rádios, mas com o tempo o serviço foi incrementado ganhando novas funcionalidades e utilizando outras técnicas de recomendação, sendo que no início somente a filtragem colaborativa era utilizada. A Figura \ref{fig:last_fm_colaborative} demonstra uma recomendação baseada na filtragem colaborativa.
% A Figura \ref{fig:last_fm_tags} demonstra uma recomendação baseada nas \textit{tags} das músicas e a 
% \begin{figure}[hbt!]
% 	\centering
% 	\includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/last_fm_tags.png}
% 	\caption{Recomendações de estilos musicais do \textit{Last.fm} baseada em \textit{Tags}.}
% 	\label{fig:last_fm_tags}
% \end{figure}

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/last_fm_colaborative.png}
	\caption{Utilização do método de filtragem colaborativa baseado em item pelo \textit{Last.fm}.}
	\label{fig:last_fm_colaborative}
\end{figure}

\subsection{Spotify}
O sistema de transmissão de música \textit{Spotify}\footnote{www.spotify.com}, criado em 2008 na Suécia, é um dos principais serviços do setor. Em março 2020 possuía um vasto catálogo de músicas totalizando 50 milhões de faixas e um grande número de usuários ativos no sistema totalizando 286 milhões. Para ligar os usuários às faixas musicais o sistema utiliza uma grande gama de técnicas de recomendação, por exemplo, a Figura \ref{fig:spotify_best_artist_and_recommended_radio} demonstra uma recomendação baseada no artista e também apresenta diversas recomendações de rádios baseando-se nas preferências do usuário. Outro exemplo é apresentado na Figura \ref{fig:spotify_personalized_recommendation} onde uma lista totalmente personalizada com 30 músicas é criada semanalmente, tomando como base as preferências do usuário.

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/spotify_best_artist_and_recommended_radio.png}
    \caption{Recomendação de artistas e rádios.}
    \label{fig:spotify_best_artist_and_recommended_radio}
\end{figure}

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/spotify_personalized_recommendation.png}
    \caption{Recomendação personalizada semanal com 30 músicas.}
    \label{fig:spotify_personalized_recommendation}
\end{figure}

\subsection{Netflix}
Empresa fundada em 1997 nos Estados Unidos com o objetivo de alugar filmes por correio. A Netflix\footnote{https://www.netflix.com} passou por mudanças ao longo de sua história e hoje utiliza a Internet para realizar a transmissão em tempo real do seu vasto catálogo de filmes. Até junho de 2020 a empresa contava com mais de 183 milhões de usuários. A Netflix em 2009 desenvolveu um projeto chamado Netflix Prize\footnote{https://www.netflixprize.com/}, onde ofereceu um prêmio de 1 milhão de dólares para a equipe que melhorasse em 10\% o seu poder de recomendação. Atualmente o sistema de recomendação da empresa utiliza diversas técnicas. A Figura \ref{fig:netflix_colaborative} demonstra a recomendação de filmes, levando em conta a popularidade entre todos os usuários e a popularidade momentânea. A Figura \ref{fig:netflix_country} demonstra três formas de recomendação: a primeira demonstra a recomendação baseada na demografia do usuário, neste caso o usuário encontra-se no Brasil; a segunda demonstra a recomendação baseada em conteúdo, onde a recomendação é feita utilizando somente filmes na língua espanhola; e por fim, a terceira linha de recomendação demonstra a recomendação levando em conta o contexto.

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/netflix_collaborative.png}
	\caption{Utilização da filtragem colaborativa levando em conta a popularidade dos itens.}
	\label{fig:netflix_colaborative}
\end{figure}

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=\textwidth]{Imagens/2-Sistemas_de_Recomendacao/netflix_country_and_age.png}
	\caption{Recomendações de filmes considerando o país, a língua e o contexto.}
	\label{fig:netflix_country}
\end{figure}

\section{Sumário}
Neste capítulo apresentamos os principais conceitos e tarefas de um sistemas de recomendação. Explanamos como modelar os dados dos usuário. Em sequência abordamos as técnicas de recomendação, debatendo detalhadamente cada técnica, abordando seus conceitos, algoritmos, vantagens e desvantagens. Após as técnicas apresentamos formas de avaliar os sistemas de recomendação, em seus protocolos e métricas. Por fim, apresentamos aplicações industriais de sistemas de recomendação. No próximo capítulo abordaremos o estado da arte sobre o tema que este trabalho visa debater.